---
password: ""
icon: ""
date: "2023-09-21"
type: Post
category: 璀璨星空
slug: FPGA011
tags:
  - 野火FPGA
summary: 用Verilog 语言描述一个具有 3-8 译码器功能的电路
title: "[野火] 第11章 简单组合逻辑 --- 译码器"
status: Published
urlname: 929b9176-8242-48c3-8fe2-2cb4518cf592
updated: "2024-02-25 12:12:00"
---

> 💡 特别鸣谢野火 FPGA 的教学与帮助！  
> 本节相关的[教程 link](https://www.bilibili.com/video/BV17z411i7er?p=8&vd_source=237e295a40d7aaea043ead8c0d2c78ab) 📌

```markdown
- 第 11 章 简单组合逻辑 --- 译码器:
  - 11.1 章节导读:
  - 11.2 理论学习:
  - 11.3 实战演练:
    - 11.3.1 实验目标:
    - 11.3.2 程序设计:
      - 1. 模块框图:
      - 2. 波形图绘制:
      - 3. 代码编写:
      - 4. 仿真验证:
  - 11.4 章末总结:
  - 11.5 拓展训练:
```

# 11.1 章节导读

---

在本章我们用 Verilog 语言描述一个具有 3-8 译码器功能的电路,通过学习 3-8 译码器继续巩固整个设计流程以及语法的使用。

# 11.2 理论学习

---

译码是编码的逆过程,在编码时,每一种二进制代码,都赋予了特定的含义,即都表示了一个确定的信号或者对象。把代码状态的特定含义翻译出来的过程叫做译码,实现译码操作的电路称为译码器。或者说,译码器是可以将输入二进制代码的状态翻译成输出信号,以表示其原来含义的电路。

译码器(decoder)是一类多输入多输出组合逻辑电路器件,其可以分为:变量译码和显示译码两类。变量译码器一般是一种较少输入变为较多输出的器件,常见的有 n 线-2^n 线译码和 8421BCD 码译码两类;显示译码器用来将二进制数转换成对应的七段码,一般其可分为驱动 LED 和驱动 LCD 两类。
最常见的变量译码器为 3-8 译码器,主要用于端口的扩展。假如我们有 8 个 led 灯需要单独控制,理论上我们需要用 8 个 I/O 口,普通的单片机也够用,但是如果我们控制的不是 8 个 led 灯,而是一个点阵屏,那就可想而知我们要使用的 I/O 口数量不是一般控制器就能满足的了,即便是 I/O 资源丰富的 FPGA 在面对巨大的点阵屏时也可能面临管脚资源不够用的尴尬境地。此种情况下使用 3-8 译码器就可以很好的解决这个问题,我们可以通过控制器控制 3 个 I/O 输出的 8 种情况来分别控制 8 个输出状态,相当于用 3 个 I/O 口就可以独立控制 8 个 led 灯,即一个 3-8 译码器就能够节约出来 5 个 I/O 口,算起来是相当合算的。现在的 3-8 译码器大都做成了独立 ASIC 芯片,价格也往往非常便宜。

# 11.3 实战演练

---

## 11.3.1 实验目标

---

设计并仿真验证 3-8 译码器。

注:3-8 译码器的上板验证需要用到 8 个 led 灯或者数码管,因为板卡 led 灯数目不够且数码管部分还未作讲解,3-8 译码器只进行仿真验证,不再上板测试,上板测试可等到数码管讲解完毕后,读者自行验证。

## 11.3.2 程序设计

---

![](https://bu.dusays.com/2023/09/21/650ba490563ef.jpeg)

### 1. 模块框图

---

模块命名 decoder3_8,模块的输入为 3 个 1bit 信号,输出为 1 个 8bit 信号,实现通过输入 3 个信号组成的二进制的 8 种情况来控制对应输出 8bit 的 8 种不同状态。根据上面的分析设计出的 Visio 框图如图 11-1 所示。

![](https://bu.dusays.com/2023/09/21/650b8e106f16a.png)

### 2. 波形图绘制

---

经分析得,输入为 3 个 1bit 信号,其任意二进制组合有 8 种情况,每种组合与 out 输出 8bit 的 8 种状态一一对应,实现由 3 种输入控制对应的 8 种输出的译码效果。我们根据上面的分析列出如表格 11-2 所示的真值表,然后再根据真值表的输入与输出的对应关系画波形图。其波形如图 11-2 所示,与真值表的关系一一对应。

![](https://bu.dusays.com/2023/09/21/650b8e114b6de.png)

![](https://bu.dusays.com/2023/09/21/650b8e122cd75.png)

### 3. 代码编写

实现 3-8 译码器功能的 Verilog 代码形式也有很多种,我们这里主要列举两种最容易理解的方法,通过这两种方法的用法对比,使学习者能对 if-else 和 case 这两种语法有一个比较深刻的理解。

![](https://bu.dusays.com/2023/09/21/650b8e1339836.png)

![](https://bu.dusays.com/2023/09/21/650b8e141d641.png)

![](https://bu.dusays.com/2023/09/21/650b8e152784a.png)

![](https://bu.dusays.com/2023/09/21/650b8e1604577.png)

经过验证对比发现两种方法虽然最后实现的功能是一样的,而所得到的 RTL 视图差别较大,但最后的逻辑资源使用却是相同的(时序逻辑中不一定相同),说明综合器进行了适当的优化。if-else 的这种写法是存在优先级的,即第一个 if 中的条件的优先级最高,后面的 if 中的条件的优先级依次递减,好在该 if 中的条件只有一个,也只会产生一种情况,并不会产生优先级的冲突,所以这里优先级的高低关系并不会对最后的功能产生任何影响。而 case 在任何时候都不存在优先级的问题,而是通过判断 case 中的条件来选择对应的输出。
通过 RTL 视图我们也能够发现 if 括号里面的条件会生成名为“EQUAL”的比较器单元,而 case 则会生成名为“DECODER”的译码器单元,这些单元并不是 FPGA 硬件底层中最小单元,而只是一种用于 RTL 视图中易于表达的抽象后的图形,使之更易于我们观察、理解其代码所实现功能的硬件结构的大致样子,也符合了“HDL(硬件描述语言)”所表述的含义。

### 4. 仿真验证

---

仿真文件编写

![](https://bu.dusays.com/2023/09/21/650b8e16d6b84.png)

![](https://bu.dusays.com/2023/09/21/650b8e17c2ddc.png)

**仿真波形分析**
通过图 11-5 所示的波形我们可以观察到,3 个输入的 in 均为任意随机数,所以由 in 组成的 3bit 数据也为随机数,而每个随机数都对一个 out 输出的 8bit 值,我们仔细核对输入 in 和输出 out 之间的对应关系,发现波形中 3 个输入信号 in 与输出信号 out 之间的对应关系和编写的代码中的译码关系是完全一致的,完全符合我们代码中的逻辑设计。

![](https://bu.dusays.com/2023/09/21/650b8e18a8337.png)

我们观察“Transcript”界面(如图 11-6 所示)中打印的结果,将其与前面绘制的真值表进行比对,发现结果是一致的,从而进一步验证了 RTL 代码设计的正确性。

![](https://bu.dusays.com/2023/09/21/650b8e19b1443.png)

# 11.4 章末总结

---

本章主要讲解了数字电路中的经典组合逻辑 3-8 译码器如何用 Verilog 代码去实现,并对比了 if-else 语句和 case 语句所表达的逻辑的异同,希望大家在以后的应用中能够合理、熟练的使用这两种语法。本章所涉及到的大部分语法和知识点都已在上一章中讲解使用过,希望大家能够强化学习,加深对语法的认知,熟练掌握 Verilog 语言中的“单词(关键字)”和“句子(常用语句)”,并大胆尝试使用。

![](https://bu.dusays.com/2023/09/21/650b8e1a8370d.png)

# 11.5 拓展训练

---

体会 if-else 和 case 语法的不同,然后自己验证观察 if-else 实现的译码器中的最后一个 else 去掉后综合后所生成的 RTL 视图是怎样的。
